from hlt import entity, positionals, game_map, constants


class BetterShip(entity.Ship):
    def __init__(self, ship_id, gmmap ):
        self.id = ship_id.id
        self.owner = ship_id.owner
        self.position = ship_id.position
        self.halite_amount = ship_id.halite_amount
        self.returning = False
        self.game_map = gmmap

#delete this later#
#class Dlete():

#creates a list of form ((x,y), halite amount, occupied or not) in ascending halite value in 4 cardinal directions
    def check_surroundings(self):
        halite_list=[]
        sorted_list=[]
        for tries in self.id.position.get_surrounding_cardinals:
            halite_list.append((tries, self.game_map[tries].halite_amount, self.game_map[tries].is_occupied))
        sorted_list = sorted(halite_list, key = lambda t: t[1])
        return(sorted_list)
    
#takes a sorted list (of form generated by check_surroundings) and returns a move to the 
#adjacent, unoccupied square with the highest halite value, or False if all squares occupied 
    def safe_move(self, sorted_list):
        for i in range(len(sorted_list)):
            if sorted_list[i][2] == True:
                sorted_list.pop(i)
        if len(sorted_list):
            return(sorted_list[-1][1])
        else:
            return False        

#returns the position of the square with the most 
#halite in a square centered around the ship +/- scope in each direction
    def get_target(self, scope):
        halite_list=[]
        for x in range(self.position.x-scope,self.position.x+scope):
            for y in range(self.position.y-scope,self.position.y+scope):
                halite_list.append((positionals.Position(x,y), self.game_map[positionals.Position(x,y)].halite_amount))
        sorted_list = sorted(halite_list, key=lambda t: t[1])
        return sorted_list[-1][1]

    def return_home(self, threshold):
        if self.halite_amount >= threshold:
            self.returning = True

    
