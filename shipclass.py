from hlt import entity, positionals, game_map, constants


class BetterShip(entity.Ship):
    def __init__(self, ship_id, gmmap):
        self.game_map = gmmap
        self.id = ship_id.id
        self.owner = ship_id.owner
        self.position = ship_id.position
        self.halite_amount = ship_id.halite_amount
        self.returning = False
        self.game_map = gmmap
        self.exploring = False
        self.target = self.position

#creates a list of form [(position, halite amount, occupied or not)] in ascending halite value in 4 cardinal directions
    def check_surroundings(self):
        halite_list=[]
        sorted_list=[]
        for coordinates in self.position.get_surrounding_cardinals():
            halite_list.append((coordinates, self.game_map[coordinates].halite_amount, self.game_map[coordinates].is_occupied))
        halite_list.append((self.position, self.game_map[coordinates].halite_amount, True))
        sorted_list = sorted(halite_list, key = lambda t: t[1])
        return(sorted_list)

    def scarce_move(self, sorted_list, min_halite):
        scarce_condition = 0
        for i in sorted_list:
            if i[1] <= min_halite / 10:
                scarce_condition += 1
        if scarce_condition >= 4:
            return True
        else:
            return False

#takes a sorted list (of form generated by check_surroundings) and returns a move to the 
#adjacent, unoccupied square with the highest halite value, or False if all squares occupied 
    def safe_move(self, sorted_list):
        final_list=[]
        for i in range(len(sorted_list)):
            if sorted_list[i][2] == False:
                final_list.append(sorted_list[i])
        if len(final_list):
            return(final_list[-1][0])
        else:
            return False        

#returns the position of the square with the most 
#halite in a square centered around the ship +/- scope in each direction
    def get_target(self, scope):
        halite_list=[]
        for x in range(self.position.x-scope,self.position.x+scope):
            for y in range(self.position.y-scope,self.position.y+scope):
                halite_list.append((positionals.Position(x,y), self.game_map[positionals.Position(x,y)].halite_amount))
        sorted_list = sorted(halite_list, key=lambda t: t[1])
        return sorted_list[-1][0]

    def get_target2(self, scope):
        return self.position.directional_offset(positionals.Direction.East)

    def return_home(self, threshold):
        if self.halite_amount >= threshold:
            self.returning = True

    
